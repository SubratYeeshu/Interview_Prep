# Minimum Spanning Tree (MST)

## Notes : - 
- Spanning tree is a tree which have n node and n - 1 edges all tightly connected
- MST is a tree with n node n - 1 edges having minimum overall weight
- Prims and Kruskal are two algorithm to find the MST 
- Prims and Kruskal are both Greedy
- TC : ELOGV for both
- SC : O(E+V)
- Prims uses pq and greedy approach
- Kruskal uses sorting based on weight and DSU

## Problem statement

Given a weighted, undirected and connected graph of V vertices and E edges. The task is to find the sum of weights of the edges of the Minimum Spanning Tree. Given  adjacency list adj as input parameters . Here adj[i] contains vectors of size 2, where the first integer in that vector denotes the end of the edge and the second integer denotes the edge weight.

## Approach 1 : Prims Algorithm 

- Time complexity : O(ELogE)  
- Auxiliary space : O(V)

```cpp
int spanningTree(int V, vector<vector<int>> adj[]){
    int sum = 0;
    vector<int> vis (V, 0);
    vector<pair<int, int>> edges;
    
    priority_queue<pair<int, pair<int, int>>, vector<pair<int, pair<int, int>>>, greater<pair<int, pair<int, int>>>> pq;
    pq.push({0, {0, -1}});
    
    while(!pq.empty()){
        int wt = pq.top().first;
        int node = pq.top().second.first;
        int par = pq.top().second.second;
        pq.pop();
        
        if(vis[node])continue;
        vis[node] = 1;
        
        // Adding weight and edges to mst
        sum += wt;
        
        // edges.push_back({node, par});
        
        
        for(auto child : adj[node]){
            int adjNode = child[0];
            int adjWt = child[1];
            
            if(!vis[adjNode]){
                pq.push({adjWt, {adjNode, node}});
            }
        }
        
    }
    
    // for(auto i : edges){
    //     cout << "{" << i.first << "," << i.second << "}, ";
    // }
    
    return sum;
}
```